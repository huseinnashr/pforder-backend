// Code generated by MockGen. DO NOT EDIT.
// Source: domain.interface.go
//
// Generated by this command:
//
//	mockgen -source=domain.interface.go -destination=domain.interface_mock.go -package=domain
//

// Package domain is a generated GoMock package.
package domain

import (
	context "context"
	sql "database/sql"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockIOrderUsecase is a mock of IOrderUsecase interface.
type MockIOrderUsecase struct {
	ctrl     *gomock.Controller
	recorder *MockIOrderUsecaseMockRecorder
}

// MockIOrderUsecaseMockRecorder is the mock recorder for MockIOrderUsecase.
type MockIOrderUsecaseMockRecorder struct {
	mock *MockIOrderUsecase
}

// NewMockIOrderUsecase creates a new mock instance.
func NewMockIOrderUsecase(ctrl *gomock.Controller) *MockIOrderUsecase {
	mock := &MockIOrderUsecase{ctrl: ctrl}
	mock.recorder = &MockIOrderUsecaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIOrderUsecase) EXPECT() *MockIOrderUsecaseMockRecorder {
	return m.recorder
}

// ListOrder mocks base method.
func (m *MockIOrderUsecase) ListOrder(ctx context.Context, params ListOrderParam) ([]Order, string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListOrder", ctx, params)
	ret0, _ := ret[0].([]Order)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListOrder indicates an expected call of ListOrder.
func (mr *MockIOrderUsecaseMockRecorder) ListOrder(ctx, params any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListOrder", reflect.TypeOf((*MockIOrderUsecase)(nil).ListOrder), ctx, params)
}

// MockIMigrateUsecase is a mock of IMigrateUsecase interface.
type MockIMigrateUsecase struct {
	ctrl     *gomock.Controller
	recorder *MockIMigrateUsecaseMockRecorder
}

// MockIMigrateUsecaseMockRecorder is the mock recorder for MockIMigrateUsecase.
type MockIMigrateUsecaseMockRecorder struct {
	mock *MockIMigrateUsecase
}

// NewMockIMigrateUsecase creates a new mock instance.
func NewMockIMigrateUsecase(ctrl *gomock.Controller) *MockIMigrateUsecase {
	mock := &MockIMigrateUsecase{ctrl: ctrl}
	mock.recorder = &MockIMigrateUsecaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIMigrateUsecase) EXPECT() *MockIMigrateUsecaseMockRecorder {
	return m.recorder
}

// MigrateAll mocks base method.
func (m *MockIMigrateUsecase) MigrateAll(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MigrateAll", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// MigrateAll indicates an expected call of MigrateAll.
func (mr *MockIMigrateUsecaseMockRecorder) MigrateAll(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MigrateAll", reflect.TypeOf((*MockIMigrateUsecase)(nil).MigrateAll), ctx)
}

// MockIOrderRepo is a mock of IOrderRepo interface.
type MockIOrderRepo struct {
	ctrl     *gomock.Controller
	recorder *MockIOrderRepoMockRecorder
}

// MockIOrderRepoMockRecorder is the mock recorder for MockIOrderRepo.
type MockIOrderRepoMockRecorder struct {
	mock *MockIOrderRepo
}

// NewMockIOrderRepo creates a new mock instance.
func NewMockIOrderRepo(ctrl *gomock.Controller) *MockIOrderRepo {
	mock := &MockIOrderRepo{ctrl: ctrl}
	mock.recorder = &MockIOrderRepoMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIOrderRepo) EXPECT() *MockIOrderRepoMockRecorder {
	return m.recorder
}

// ListOrder mocks base method.
func (m *MockIOrderRepo) ListOrder(ctx context.Context, params ListOrderParam) ([]Order, string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListOrder", ctx, params)
	ret0, _ := ret[0].([]Order)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListOrder indicates an expected call of ListOrder.
func (mr *MockIOrderRepoMockRecorder) ListOrder(ctx, params any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListOrder", reflect.TypeOf((*MockIOrderRepo)(nil).ListOrder), ctx, params)
}

// MockIMigrateRepo is a mock of IMigrateRepo interface.
type MockIMigrateRepo struct {
	ctrl     *gomock.Controller
	recorder *MockIMigrateRepoMockRecorder
}

// MockIMigrateRepoMockRecorder is the mock recorder for MockIMigrateRepo.
type MockIMigrateRepoMockRecorder struct {
	mock *MockIMigrateRepo
}

// NewMockIMigrateRepo creates a new mock instance.
func NewMockIMigrateRepo(ctrl *gomock.Controller) *MockIMigrateRepo {
	mock := &MockIMigrateRepo{ctrl: ctrl}
	mock.recorder = &MockIMigrateRepoMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIMigrateRepo) EXPECT() *MockIMigrateRepoMockRecorder {
	return m.recorder
}

// CSVToDB mocks base method.
func (m *MockIMigrateRepo) CSVToDB(ctx context.Context, dbTx ISQLDatabaseTx, params CSVToDBParam) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CSVToDB", ctx, dbTx, params)
	ret0, _ := ret[0].(error)
	return ret0
}

// CSVToDB indicates an expected call of CSVToDB.
func (mr *MockIMigrateRepoMockRecorder) CSVToDB(ctx, dbTx, params any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CSVToDB", reflect.TypeOf((*MockIMigrateRepo)(nil).CSVToDB), ctx, dbTx, params)
}

// MockISQLDatabase is a mock of ISQLDatabase interface.
type MockISQLDatabase struct {
	ctrl     *gomock.Controller
	recorder *MockISQLDatabaseMockRecorder
}

// MockISQLDatabaseMockRecorder is the mock recorder for MockISQLDatabase.
type MockISQLDatabaseMockRecorder struct {
	mock *MockISQLDatabase
}

// NewMockISQLDatabase creates a new mock instance.
func NewMockISQLDatabase(ctrl *gomock.Controller) *MockISQLDatabase {
	mock := &MockISQLDatabase{ctrl: ctrl}
	mock.recorder = &MockISQLDatabaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockISQLDatabase) EXPECT() *MockISQLDatabaseMockRecorder {
	return m.recorder
}

// BeginTx mocks base method.
func (m *MockISQLDatabase) BeginTx(ctx context.Context, opts *sql.TxOptions) (*sql.Tx, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BeginTx", ctx, opts)
	ret0, _ := ret[0].(*sql.Tx)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BeginTx indicates an expected call of BeginTx.
func (mr *MockISQLDatabaseMockRecorder) BeginTx(ctx, opts any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeginTx", reflect.TypeOf((*MockISQLDatabase)(nil).BeginTx), ctx, opts)
}

// ExecContext mocks base method.
func (m *MockISQLDatabase) ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExecContext", varargs...)
	ret0, _ := ret[0].(sql.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecContext indicates an expected call of ExecContext.
func (mr *MockISQLDatabaseMockRecorder) ExecContext(ctx, query any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecContext", reflect.TypeOf((*MockISQLDatabase)(nil).ExecContext), varargs...)
}

// QueryContext mocks base method.
func (m *MockISQLDatabase) QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryContext", varargs...)
	ret0, _ := ret[0].(*sql.Rows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueryContext indicates an expected call of QueryContext.
func (mr *MockISQLDatabaseMockRecorder) QueryContext(ctx, query any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryContext", reflect.TypeOf((*MockISQLDatabase)(nil).QueryContext), varargs...)
}

// QueryRowContext mocks base method.
func (m *MockISQLDatabase) QueryRowContext(ctx context.Context, query string, args ...any) *sql.Row {
	m.ctrl.T.Helper()
	varargs := []any{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryRowContext", varargs...)
	ret0, _ := ret[0].(*sql.Row)
	return ret0
}

// QueryRowContext indicates an expected call of QueryRowContext.
func (mr *MockISQLDatabaseMockRecorder) QueryRowContext(ctx, query any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRowContext", reflect.TypeOf((*MockISQLDatabase)(nil).QueryRowContext), varargs...)
}

// MockISQLDatabaseTx is a mock of ISQLDatabaseTx interface.
type MockISQLDatabaseTx struct {
	ctrl     *gomock.Controller
	recorder *MockISQLDatabaseTxMockRecorder
}

// MockISQLDatabaseTxMockRecorder is the mock recorder for MockISQLDatabaseTx.
type MockISQLDatabaseTxMockRecorder struct {
	mock *MockISQLDatabaseTx
}

// NewMockISQLDatabaseTx creates a new mock instance.
func NewMockISQLDatabaseTx(ctrl *gomock.Controller) *MockISQLDatabaseTx {
	mock := &MockISQLDatabaseTx{ctrl: ctrl}
	mock.recorder = &MockISQLDatabaseTxMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockISQLDatabaseTx) EXPECT() *MockISQLDatabaseTxMockRecorder {
	return m.recorder
}

// Commit mocks base method.
func (m *MockISQLDatabaseTx) Commit() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit")
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockISQLDatabaseTxMockRecorder) Commit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockISQLDatabaseTx)(nil).Commit))
}

// ExecContext mocks base method.
func (m *MockISQLDatabaseTx) ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExecContext", varargs...)
	ret0, _ := ret[0].(sql.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecContext indicates an expected call of ExecContext.
func (mr *MockISQLDatabaseTxMockRecorder) ExecContext(ctx, query any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecContext", reflect.TypeOf((*MockISQLDatabaseTx)(nil).ExecContext), varargs...)
}

// Rollback mocks base method.
func (m *MockISQLDatabaseTx) Rollback() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rollback")
	ret0, _ := ret[0].(error)
	return ret0
}

// Rollback indicates an expected call of Rollback.
func (mr *MockISQLDatabaseTxMockRecorder) Rollback() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*MockISQLDatabaseTx)(nil).Rollback))
}
